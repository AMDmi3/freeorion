#ifndef _Logger_h_
#define _Logger_h_

#include <boost/log/sources/severity_channel_logger.hpp>
#include <boost/log/expressions/keyword.hpp>
#include <boost/log/utility/manipulators/add_value.hpp>
#include <boost/log/sources/global_logger_storage.hpp>
#include <boost/signals2/signal.hpp>

#ifdef FREEORION_WIN32
// Note: The is a workaround for Visual C++ non-conformant pre-processor
// handling of empty macro arguments.
// https://msdn.microsoft.com/en-us/library/hh567368.aspx
// https://blogs.msdn.microsoft.com/vcblog/2017/03/07/c-standards-conformance-from-microsoft/
#include <boost/preprocessor/control/if.hpp>
#include <boost/preprocessor/facilities/is_empty_variadic.hpp>
#endif

#include <string>
#include <set>
#include <tuple>

#include "Export.h"


/** \file
    \brief The logging system consists of named loggers with levels.

    The system is a thin wrapper around boost::log.

    The logging system is composed of a sink which writes to the log files and
    sources, called loggers, which collect the log information while the
    application is running.

    Both the sinks and the sources use debug levels (trace, debug, info, warn and
    error) to filter which log records are generated at the sources and which
    log records are written at the sinks. Logs that are filtered out at either
    the sink or the source are not generated by the source.

    The intended uses of the levels are:
    error - used for "major" unrecoverable errors which will affect game play.  Error level issues
            need to be fixed.  Error level will probably not be turned off unless they are flooding
            the logs.
            Examples are: the game is about to crash, a string is missing from the stringtable, etc.
    warn  - used for "minor", recoverable errors that will not affect game play but do indicate a
            problem.
            For example a missing id that can be ignored, an extra item in a container.
    info  - used to report normal game state and progress.  This should be the default level of
            logging.  The number of log should be low enought to not floow the logs.
            For example reporting that the network connected/disconnected.
    debug - used for low-level implementation or calculation details.  For a named logger this
            level will probably only be turned on by devs working on that
            section of code.  This will be detailed and perhaps voluminous.
            For example reporting that the network disconnected via a client initiated shutdown
            with a linger time of 30 ms before closing.
    trace - used for the highest detail of logging.

    Sources are further filtered by name.  For example "combat" is the name of the combat system's logger.

    Usage:

    The default loggers as stream outputs, like std::cout as follow:

    ErrorLogger() << "Put any streamable output here.  It will only be
                  << "computed at the error threshold or greater.";
    WarnLogger()  << "Put any streamable output here.  It will only be
                  << "computed at the warn threshold or greater.";
    InfoLogger()  << "Put any streamable output here.  It will only be
                  << "computed at the info threshold or greater.";
    DebugLogger() << "Put any streamable output here.  It will only be
                  << "computed at the debug threshold or greater.";
    TraceLogger() << "Put any streamable output here.  It will only be
                  << "computed at the trace threshold or greater.";

    The named loggers are created with:
    CreateThreadedLogger(name_of_logger);

    And used with

    ErrorLogger(name_of_logger) << "any streamable output, only computed "
                                << "at the error threshold or greater "
                                << "for the 'name_of_logger' logger.";
    WarnLogger(name_of_logger)  << "streamable output";
    InfoLogger(name_of_logger)  << "streamable output";
    DebugLogger(name_of_logger) << "streamable output";
    TraceLogger(name_of_logger) << "streamable output";
*/

// The logging levels.
enum class LogLevel {trace, debug, info, warn, error};

constexpr LogLevel max_LogLevel = LogLevel::error;
constexpr LogLevel min_LogLevel = LogLevel::trace;

FO_COMMON_API std::string to_string(const LogLevel level);
FO_COMMON_API LogLevel to_LogLevel(const std::string& name);

// Prefix \p name to create a global logger name less likely to collide.
#ifndef FREEORION_WIN32

#define FO_GLOBAL_LOGGER_NAME(name) fo_logger_global_##name

#else

// Note: The is a workaround for Visual C++ non-conformant pre-processor
// handling of empty macro arguments.
// https://msdn.microsoft.com/en-us/library/hh567368.aspx
// https://blogs.msdn.microsoft.com/vcblog/2017/03/07/c-standards-conformance-from-microsoft/
#define FO_GLOBAL_LOGGER_NAME_NO_ARG() fo_logger_global_
#define FO_GLOBAL_LOGGER_NAME_ONE_ARG(name) fo_logger_global_##name
#define FO_GLOBAL_LOGGER_NAME(...)                                      \
    BOOST_PP_IF(BOOST_PP_IS_EMPTY(__VA_ARGS__),                         \
                FO_GLOBAL_LOGGER_NAME_NO_ARG(),                         \
                FO_GLOBAL_LOGGER_NAME_ONE_ARG(__VA_ARGS__))

#endif

/** Initializes the logging system. Log to the given file.  If the file already
 * exists it will be deleted. \p default_exec_logger_name is the name by which the
 * default logger "" appears in the log file.*/
FO_COMMON_API void InitLoggingSystem(const std::string& logFile, const std::string& default_exec_logger_name);

/** Overrides all logger thresholds to \p threshold.*/
FO_COMMON_API void OverrideLoggerThresholds(const LogLevel threshold);

FO_COMMON_API const std::string& DefaultExecLoggerName();

/** A type for loggers (sources) that allows for severity and a logger name (channel in
    boost parlance) and supports multithreading.*/
using NamedThreadedLogger = boost::log::sources::severity_channel_logger_mt<
    LogLevel,     ///< the type of the severity level
    std::string   ///< the channel name of the logger
    >;

// Setup file sink, formatting, and \p name channel filter for \p logger.
FO_COMMON_API void ConfigureLogger(NamedThreadedLogger& logger, const std::string& name);

// Place in source file to create the previously defined global logger \p name
#define CreateThreadedLogger(name)                                      \
    BOOST_LOG_INLINE_GLOBAL_LOGGER_INIT(                                \
        FO_GLOBAL_LOGGER_NAME(name), NamedThreadedLogger)               \
    {                                                                   \
        auto lg = NamedThreadedLogger(                                  \
            (boost::log::keywords::severity = LogLevel::debug),         \
            (boost::log::keywords::channel = #name));                   \
        ConfigureLogger(lg, #name);                                     \
        return lg;                                                      \
    }

// Signal that logger \p name has been created
using LoggerCreatedSignalType = boost::signals2::signal<void (const std::string logger)>;
FO_COMMON_API extern LoggerCreatedSignalType LoggerCreatedSignal;

// Create the default logger
#ifndef FREEORION_WIN32

CreateThreadedLogger();

#else

// Note: The is a workaround for Visual C++ non-conformant pre-processor
// handling of empty macro arguments.
// https://msdn.microsoft.com/en-us/library/hh567368.aspx
// https://blogs.msdn.microsoft.com/vcblog/2017/03/07/c-standards-conformance-from-microsoft/
BOOST_LOG_INLINE_GLOBAL_LOGGER_INIT(                                    \
    fo_logger_global_, NamedThreadedLogger)                             \
{                                                                       \
    auto lg = NamedThreadedLogger(                                      \
        (boost::log::keywords::severity = LogLevel::debug),             \
        (boost::log::keywords::channel = ""));                          \
    ConfigureLogger(lg, "");                                            \
    return lg;                                                          \
}

#endif

BOOST_LOG_ATTRIBUTE_KEYWORD(log_severity, "Severity", LogLevel);
BOOST_LOG_ATTRIBUTE_KEYWORD(log_channel, "Channel", std::string)
BOOST_LOG_ATTRIBUTE_KEYWORD(log_src_filename, "SrcFilename", std::string);
BOOST_LOG_ATTRIBUTE_KEYWORD(log_src_linenum, "SrcLinenum", int);

#define __BASE_FILENAME__ (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : strrchr(__FILE__, '\\') ? strrchr(__FILE__, '\\') + 1 : __FILE__)

#ifndef FREEORION_WIN32

#define FO_LOGGER(name, lvl)                                            \
    BOOST_LOG_STREAM_WITH_PARAMS(                                       \
        FO_GLOBAL_LOGGER_NAME(name)::get(),                             \
        (boost::log::keywords::severity = lvl))                         \
    << boost::log::add_value("SrcFilename", __BASE_FILENAME__)          \
    << boost::log::add_value("SrcLinenum", __LINE__)

#define TraceLogger(name) FO_LOGGER(name, LogLevel::trace)

#define DebugLogger(name) FO_LOGGER(name, LogLevel::debug)

#define InfoLogger(name) FO_LOGGER(name, LogLevel::info)

#define WarnLogger(name) FO_LOGGER(name, LogLevel::warn)

#define ErrorLogger(name) FO_LOGGER(name, LogLevel::error)


#else


// Note: The is a workaround for Visual C++ non-conformant pre-processor
// handling of empty macro arguments.
// https://msdn.microsoft.com/en-us/library/hh567368.aspx
// https://blogs.msdn.microsoft.com/vcblog/2017/03/07/c-standards-conformance-from-microsoft/
#define FO_LOGGER_PRESTITCHED(lvl, logger)                              \
    BOOST_LOG_STREAM_WITH_PARAMS(                                       \
        logger::get(),                                                  \
        (boost::log::keywords::severity = lvl))                         \
    << boost::log::add_value("SrcFilename", __BASE_FILENAME__)          \
    << boost::log::add_value("SrcLinenum", __LINE__)

#define TraceLogger(...) FO_LOGGER_PRESTITCHED(LogLevel::trace, fo_logger_global_##__VA_ARGS__)
#define DebugLogger(...) FO_LOGGER_PRESTITCHED(LogLevel::debug, fo_logger_global_##__VA_ARGS__)
#define InfoLogger(...)  FO_LOGGER_PRESTITCHED(LogLevel::info,  fo_logger_global_##__VA_ARGS__)
#define WarnLogger(...)  FO_LOGGER_PRESTITCHED(LogLevel::warn,  fo_logger_global_##__VA_ARGS__)
#define ErrorLogger(...) FO_LOGGER_PRESTITCHED(LogLevel::error, fo_logger_global_##__VA_ARGS__)


#endif

/** Sets the \p threshold of \p source.  \p source == "" is the default logger.*/
FO_COMMON_API void SetLoggerThreshold(const std::string& source, LogLevel threshold);

extern int g_indent;

/** A function that returns the correct amount of spacing for the current
  * indentation level during a dump. */
std::string DumpIndent();

#endif // _Logger_h_
